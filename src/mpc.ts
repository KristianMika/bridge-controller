// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "mpc.proto" (package "meesign", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message meesign.ServerInfoRequest
 */
export interface ServerInfoRequest {
}
/**
 * @generated from protobuf message meesign.ServerInfo
 */
export interface ServerInfo {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
}
/**
 * @generated from protobuf message meesign.RegistrationRequest
 */
export interface RegistrationRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: bytes csr = 2;
     */
    csr: Uint8Array; // CSR in DER format
}
/**
 * @generated from protobuf message meesign.RegistrationResponse
 */
export interface RegistrationResponse {
    /**
     * @generated from protobuf field: bytes device_id = 1;
     */
    deviceId: Uint8Array;
    /**
     * @generated from protobuf field: bytes certificate = 2;
     */
    certificate: Uint8Array; // cert in DER format
}
/**
 * @generated from protobuf message meesign.GroupRequest
 */
export interface GroupRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated bytes device_ids = 2;
     */
    deviceIds: Uint8Array[];
    /**
     * @generated from protobuf field: uint32 threshold = 3;
     */
    threshold: number;
    /**
     * @generated from protobuf field: meesign.ProtocolType protocol = 4;
     */
    protocol: ProtocolType;
    /**
     * @generated from protobuf field: meesign.KeyType key_type = 5;
     */
    keyType: KeyType;
}
/**
 * @generated from protobuf message meesign.Group
 */
export interface Group {
    /**
     * @generated from protobuf field: bytes identifier = 1;
     */
    identifier: Uint8Array;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: uint32 threshold = 3;
     */
    threshold: number;
    /**
     * @generated from protobuf field: meesign.ProtocolType protocol = 4;
     */
    protocol: ProtocolType;
    /**
     * @generated from protobuf field: meesign.KeyType key_type = 5;
     */
    keyType: KeyType;
    /**
     * @generated from protobuf field: repeated bytes device_ids = 6;
     */
    deviceIds: Uint8Array[];
}
/**
 * Protocol
 *
 * @generated from protobuf message meesign.DevicesRequest
 */
export interface DevicesRequest {
}
/**
 * @generated from protobuf message meesign.Devices
 */
export interface Devices {
    /**
     * @generated from protobuf field: repeated meesign.Device devices = 1;
     */
    devices: Device[];
}
/**
 * @generated from protobuf message meesign.Device
 */
export interface Device {
    /**
     * @generated from protobuf field: bytes identifier = 1;
     */
    identifier: Uint8Array;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: bytes certificate = 3;
     */
    certificate: Uint8Array;
    /**
     * @generated from protobuf field: uint64 last_active = 4;
     */
    lastActive: bigint;
}
/**
 * @generated from protobuf message meesign.SignRequest
 */
export interface SignRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: bytes group_id = 2;
     */
    groupId: Uint8Array;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message meesign.DecryptRequest
 */
export interface DecryptRequest {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: bytes group_id = 2;
     */
    groupId: Uint8Array;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message meesign.TaskRequest
 */
export interface TaskRequest {
    /**
     * @generated from protobuf field: bytes task_id = 1;
     */
    taskId: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes device_id = 2;
     */
    deviceId?: Uint8Array;
}
/**
 * @generated from protobuf message meesign.Task
 */
export interface Task {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: meesign.TaskType type = 2;
     */
    type: TaskType;
    /**
     * @generated from protobuf field: meesign.Task.TaskState state = 3;
     */
    state: Task_TaskState;
    /**
     * @generated from protobuf field: uint32 round = 4;
     */
    round: number;
    /**
     * @generated from protobuf field: uint32 attempt = 5;
     */
    attempt: number;
    /**
     * @generated from protobuf field: uint32 accept = 6;
     */
    accept: number; // Number of task accepts
    /**
     * @generated from protobuf field: uint32 reject = 7;
     */
    reject: number; // Number of task rejects
    /**
     * @generated from protobuf field: optional bytes data = 8;
     */
    data?: Uint8Array; // If present, the task is waiting for recipient's action
    /**
     * @generated from protobuf field: optional bytes request = 9;
     */
    request?: Uint8Array; // Serialized SignRequest or TaskRequest; present only when queried directly
}
/**
 * @generated from protobuf enum meesign.Task.TaskState
 */
export enum Task_TaskState {
    /**
     * @generated from protobuf enum value: CREATED = 0;
     */
    CREATED = 0,
    /**
     * @generated from protobuf enum value: RUNNING = 1;
     */
    RUNNING = 1,
    /**
     * @generated from protobuf enum value: FINISHED = 2;
     */
    FINISHED = 2,
    /**
     * @generated from protobuf enum value: FAILED = 3;
     */
    FAILED = 3
}
/**
 * @generated from protobuf message meesign.TaskUpdate
 */
export interface TaskUpdate {
    /**
     * @generated from protobuf field: bytes task = 1;
     */
    task: Uint8Array;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: uint32 attempt = 3;
     */
    attempt: number;
}
/**
 * @generated from protobuf message meesign.TasksRequest
 */
export interface TasksRequest {
    /**
     * @generated from protobuf field: optional bytes device_id = 1;
     */
    deviceId?: Uint8Array;
}
/**
 * @generated from protobuf message meesign.Tasks
 */
export interface Tasks {
    /**
     * @generated from protobuf field: repeated meesign.Task tasks = 1;
     */
    tasks: Task[];
}
/**
 * @generated from protobuf message meesign.GroupsRequest
 */
export interface GroupsRequest {
    /**
     * @generated from protobuf field: optional bytes device_id = 1;
     */
    deviceId?: Uint8Array;
}
/**
 * @generated from protobuf message meesign.Groups
 */
export interface Groups {
    /**
     * @generated from protobuf field: repeated meesign.Group groups = 1;
     */
    groups: Group[];
}
/**
 * @generated from protobuf message meesign.Resp
 */
export interface Resp {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message meesign.TaskDecision
 */
export interface TaskDecision {
    /**
     * @generated from protobuf field: bytes task = 1;
     */
    task: Uint8Array;
    /**
     * @generated from protobuf field: bool accept = 2;
     */
    accept: boolean;
}
/**
 * @generated from protobuf message meesign.TaskAcknowledgement
 */
export interface TaskAcknowledgement {
    /**
     * @generated from protobuf field: bytes task_id = 1;
     */
    taskId: Uint8Array;
}
/**
 * @generated from protobuf message meesign.LogRequest
 */
export interface LogRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message meesign.SubscribeRequest
 */
export interface SubscribeRequest {
}
/**
 * @generated from protobuf enum meesign.ProtocolType
 */
export enum ProtocolType {
    /**
     * @generated from protobuf enum value: GG18 = 0;
     */
    GG18 = 0,
    /**
     * @generated from protobuf enum value: ELGAMAL = 1;
     */
    ELGAMAL = 1,
    /**
     * @generated from protobuf enum value: FROST = 2;
     */
    FROST = 2
}
/**
 * @generated from protobuf enum meesign.KeyType
 */
export enum KeyType {
    /**
     * @generated from protobuf enum value: SignPDF = 0;
     */
    SignPDF = 0,
    /**
     * @generated from protobuf enum value: SignChallenge = 1;
     */
    SignChallenge = 1,
    /**
     * @generated from protobuf enum value: Decrypt = 2;
     */
    Decrypt = 2
}
/**
 * @generated from protobuf enum meesign.TaskType
 */
export enum TaskType {
    /**
     * @generated from protobuf enum value: GROUP = 0;
     */
    GROUP = 0,
    /**
     * @generated from protobuf enum value: SIGN_PDF = 1;
     */
    SIGN_PDF = 1,
    /**
     * @generated from protobuf enum value: SIGN_CHALLENGE = 2;
     */
    SIGN_CHALLENGE = 2,
    /**
     * @generated from protobuf enum value: DECRYPT = 3;
     */
    DECRYPT = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class ServerInfoRequest$Type extends MessageType<ServerInfoRequest> {
    constructor() {
        super("meesign.ServerInfoRequest", []);
    }
    create(value?: PartialMessage<ServerInfoRequest>): ServerInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerInfoRequest): ServerInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ServerInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.ServerInfoRequest
 */
export const ServerInfoRequest = new ServerInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerInfo$Type extends MessageType<ServerInfo> {
    constructor() {
        super("meesign.ServerInfo", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ServerInfo>): ServerInfo {
        const message = { version: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerInfo): ServerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.ServerInfo
 */
export const ServerInfo = new ServerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegistrationRequest$Type extends MessageType<RegistrationRequest> {
    constructor() {
        super("meesign.RegistrationRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "csr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RegistrationRequest>): RegistrationRequest {
        const message = { name: "", csr: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegistrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegistrationRequest): RegistrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bytes csr */ 2:
                    message.csr = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegistrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bytes csr = 2; */
        if (message.csr.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.csr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.RegistrationRequest
 */
export const RegistrationRequest = new RegistrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegistrationResponse$Type extends MessageType<RegistrationResponse> {
    constructor() {
        super("meesign.RegistrationResponse", [
            { no: 1, name: "device_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "certificate", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RegistrationResponse>): RegistrationResponse {
        const message = { deviceId: new Uint8Array(0), certificate: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegistrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegistrationResponse): RegistrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes device_id */ 1:
                    message.deviceId = reader.bytes();
                    break;
                case /* bytes certificate */ 2:
                    message.certificate = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegistrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes device_id = 1; */
        if (message.deviceId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.deviceId);
        /* bytes certificate = 2; */
        if (message.certificate.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.certificate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.RegistrationResponse
 */
export const RegistrationResponse = new RegistrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupRequest$Type extends MessageType<GroupRequest> {
    constructor() {
        super("meesign.GroupRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "device_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "threshold", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "protocol", kind: "enum", T: () => ["meesign.ProtocolType", ProtocolType] },
            { no: 5, name: "key_type", kind: "enum", T: () => ["meesign.KeyType", KeyType] }
        ]);
    }
    create(value?: PartialMessage<GroupRequest>): GroupRequest {
        const message = { name: "", deviceIds: [], threshold: 0, protocol: 0, keyType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GroupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupRequest): GroupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated bytes device_ids */ 2:
                    message.deviceIds.push(reader.bytes());
                    break;
                case /* uint32 threshold */ 3:
                    message.threshold = reader.uint32();
                    break;
                case /* meesign.ProtocolType protocol */ 4:
                    message.protocol = reader.int32();
                    break;
                case /* meesign.KeyType key_type */ 5:
                    message.keyType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated bytes device_ids = 2; */
        for (let i = 0; i < message.deviceIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.deviceIds[i]);
        /* uint32 threshold = 3; */
        if (message.threshold !== 0)
            writer.tag(3, WireType.Varint).uint32(message.threshold);
        /* meesign.ProtocolType protocol = 4; */
        if (message.protocol !== 0)
            writer.tag(4, WireType.Varint).int32(message.protocol);
        /* meesign.KeyType key_type = 5; */
        if (message.keyType !== 0)
            writer.tag(5, WireType.Varint).int32(message.keyType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.GroupRequest
 */
export const GroupRequest = new GroupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Group$Type extends MessageType<Group> {
    constructor() {
        super("meesign.Group", [
            { no: 1, name: "identifier", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "threshold", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "protocol", kind: "enum", T: () => ["meesign.ProtocolType", ProtocolType] },
            { no: 5, name: "key_type", kind: "enum", T: () => ["meesign.KeyType", KeyType] },
            { no: 6, name: "device_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Group>): Group {
        const message = { identifier: new Uint8Array(0), name: "", threshold: 0, protocol: 0, keyType: 0, deviceIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Group>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Group): Group {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes identifier */ 1:
                    message.identifier = reader.bytes();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* uint32 threshold */ 3:
                    message.threshold = reader.uint32();
                    break;
                case /* meesign.ProtocolType protocol */ 4:
                    message.protocol = reader.int32();
                    break;
                case /* meesign.KeyType key_type */ 5:
                    message.keyType = reader.int32();
                    break;
                case /* repeated bytes device_ids */ 6:
                    message.deviceIds.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Group, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes identifier = 1; */
        if (message.identifier.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.identifier);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* uint32 threshold = 3; */
        if (message.threshold !== 0)
            writer.tag(3, WireType.Varint).uint32(message.threshold);
        /* meesign.ProtocolType protocol = 4; */
        if (message.protocol !== 0)
            writer.tag(4, WireType.Varint).int32(message.protocol);
        /* meesign.KeyType key_type = 5; */
        if (message.keyType !== 0)
            writer.tag(5, WireType.Varint).int32(message.keyType);
        /* repeated bytes device_ids = 6; */
        for (let i = 0; i < message.deviceIds.length; i++)
            writer.tag(6, WireType.LengthDelimited).bytes(message.deviceIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.Group
 */
export const Group = new Group$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DevicesRequest$Type extends MessageType<DevicesRequest> {
    constructor() {
        super("meesign.DevicesRequest", []);
    }
    create(value?: PartialMessage<DevicesRequest>): DevicesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DevicesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DevicesRequest): DevicesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DevicesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.DevicesRequest
 */
export const DevicesRequest = new DevicesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Devices$Type extends MessageType<Devices> {
    constructor() {
        super("meesign.Devices", [
            { no: 1, name: "devices", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Device }
        ]);
    }
    create(value?: PartialMessage<Devices>): Devices {
        const message = { devices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Devices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Devices): Devices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated meesign.Device devices */ 1:
                    message.devices.push(Device.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Devices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated meesign.Device devices = 1; */
        for (let i = 0; i < message.devices.length; i++)
            Device.internalBinaryWrite(message.devices[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.Devices
 */
export const Devices = new Devices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Device$Type extends MessageType<Device> {
    constructor() {
        super("meesign.Device", [
            { no: 1, name: "identifier", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "certificate", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "last_active", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Device>): Device {
        const message = { identifier: new Uint8Array(0), name: "", certificate: new Uint8Array(0), lastActive: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Device>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Device): Device {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes identifier */ 1:
                    message.identifier = reader.bytes();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bytes certificate */ 3:
                    message.certificate = reader.bytes();
                    break;
                case /* uint64 last_active */ 4:
                    message.lastActive = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Device, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes identifier = 1; */
        if (message.identifier.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.identifier);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bytes certificate = 3; */
        if (message.certificate.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.certificate);
        /* uint64 last_active = 4; */
        if (message.lastActive !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.lastActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.Device
 */
export const Device = new Device$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignRequest$Type extends MessageType<SignRequest> {
    constructor() {
        super("meesign.SignRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "group_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SignRequest>): SignRequest {
        const message = { name: "", groupId: new Uint8Array(0), data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignRequest): SignRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bytes group_id */ 2:
                    message.groupId = reader.bytes();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bytes group_id = 2; */
        if (message.groupId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.groupId);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.SignRequest
 */
export const SignRequest = new SignRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecryptRequest$Type extends MessageType<DecryptRequest> {
    constructor() {
        super("meesign.DecryptRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "group_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<DecryptRequest>): DecryptRequest {
        const message = { name: "", groupId: new Uint8Array(0), data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DecryptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecryptRequest): DecryptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* bytes group_id */ 2:
                    message.groupId = reader.bytes();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecryptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bytes group_id = 2; */
        if (message.groupId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.groupId);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.DecryptRequest
 */
export const DecryptRequest = new DecryptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskRequest$Type extends MessageType<TaskRequest> {
    constructor() {
        super("meesign.TaskRequest", [
            { no: 1, name: "task_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "device_id", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TaskRequest>): TaskRequest {
        const message = { taskId: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TaskRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskRequest): TaskRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes task_id */ 1:
                    message.taskId = reader.bytes();
                    break;
                case /* optional bytes device_id */ 2:
                    message.deviceId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes task_id = 1; */
        if (message.taskId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.taskId);
        /* optional bytes device_id = 2; */
        if (message.deviceId !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.deviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.TaskRequest
 */
export const TaskRequest = new TaskRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Task$Type extends MessageType<Task> {
    constructor() {
        super("meesign.Task", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["meesign.TaskType", TaskType] },
            { no: 3, name: "state", kind: "enum", T: () => ["meesign.Task.TaskState", Task_TaskState] },
            { no: 4, name: "round", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "attempt", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "accept", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "reject", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "request", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Task>): Task {
        const message = { id: new Uint8Array(0), type: 0, state: 0, round: 0, attempt: 0, accept: 0, reject: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Task>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Task): Task {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* meesign.TaskType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* meesign.Task.TaskState state */ 3:
                    message.state = reader.int32();
                    break;
                case /* uint32 round */ 4:
                    message.round = reader.uint32();
                    break;
                case /* uint32 attempt */ 5:
                    message.attempt = reader.uint32();
                    break;
                case /* uint32 accept */ 6:
                    message.accept = reader.uint32();
                    break;
                case /* uint32 reject */ 7:
                    message.reject = reader.uint32();
                    break;
                case /* optional bytes data */ 8:
                    message.data = reader.bytes();
                    break;
                case /* optional bytes request */ 9:
                    message.request = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Task, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* meesign.TaskType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* meesign.Task.TaskState state = 3; */
        if (message.state !== 0)
            writer.tag(3, WireType.Varint).int32(message.state);
        /* uint32 round = 4; */
        if (message.round !== 0)
            writer.tag(4, WireType.Varint).uint32(message.round);
        /* uint32 attempt = 5; */
        if (message.attempt !== 0)
            writer.tag(5, WireType.Varint).uint32(message.attempt);
        /* uint32 accept = 6; */
        if (message.accept !== 0)
            writer.tag(6, WireType.Varint).uint32(message.accept);
        /* uint32 reject = 7; */
        if (message.reject !== 0)
            writer.tag(7, WireType.Varint).uint32(message.reject);
        /* optional bytes data = 8; */
        if (message.data !== undefined)
            writer.tag(8, WireType.LengthDelimited).bytes(message.data);
        /* optional bytes request = 9; */
        if (message.request !== undefined)
            writer.tag(9, WireType.LengthDelimited).bytes(message.request);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.Task
 */
export const Task = new Task$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskUpdate$Type extends MessageType<TaskUpdate> {
    constructor() {
        super("meesign.TaskUpdate", [
            { no: 1, name: "task", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "attempt", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TaskUpdate>): TaskUpdate {
        const message = { task: new Uint8Array(0), data: new Uint8Array(0), attempt: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TaskUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskUpdate): TaskUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes task */ 1:
                    message.task = reader.bytes();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* uint32 attempt */ 3:
                    message.attempt = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes task = 1; */
        if (message.task.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.task);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* uint32 attempt = 3; */
        if (message.attempt !== 0)
            writer.tag(3, WireType.Varint).uint32(message.attempt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.TaskUpdate
 */
export const TaskUpdate = new TaskUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TasksRequest$Type extends MessageType<TasksRequest> {
    constructor() {
        super("meesign.TasksRequest", [
            { no: 1, name: "device_id", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TasksRequest>): TasksRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TasksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TasksRequest): TasksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes device_id */ 1:
                    message.deviceId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TasksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes device_id = 1; */
        if (message.deviceId !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.deviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.TasksRequest
 */
export const TasksRequest = new TasksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tasks$Type extends MessageType<Tasks> {
    constructor() {
        super("meesign.Tasks", [
            { no: 1, name: "tasks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Task }
        ]);
    }
    create(value?: PartialMessage<Tasks>): Tasks {
        const message = { tasks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tasks>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tasks): Tasks {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated meesign.Task tasks */ 1:
                    message.tasks.push(Task.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tasks, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated meesign.Task tasks = 1; */
        for (let i = 0; i < message.tasks.length; i++)
            Task.internalBinaryWrite(message.tasks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.Tasks
 */
export const Tasks = new Tasks$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupsRequest$Type extends MessageType<GroupsRequest> {
    constructor() {
        super("meesign.GroupsRequest", [
            { no: 1, name: "device_id", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GroupsRequest>): GroupsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GroupsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupsRequest): GroupsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes device_id */ 1:
                    message.deviceId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes device_id = 1; */
        if (message.deviceId !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.deviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.GroupsRequest
 */
export const GroupsRequest = new GroupsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Groups$Type extends MessageType<Groups> {
    constructor() {
        super("meesign.Groups", [
            { no: 1, name: "groups", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Group }
        ]);
    }
    create(value?: PartialMessage<Groups>): Groups {
        const message = { groups: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Groups>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Groups): Groups {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated meesign.Group groups */ 1:
                    message.groups.push(Group.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Groups, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated meesign.Group groups = 1; */
        for (let i = 0; i < message.groups.length; i++)
            Group.internalBinaryWrite(message.groups[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.Groups
 */
export const Groups = new Groups$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resp$Type extends MessageType<Resp> {
    constructor() {
        super("meesign.Resp", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Resp>): Resp {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Resp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resp): Resp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.Resp
 */
export const Resp = new Resp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskDecision$Type extends MessageType<TaskDecision> {
    constructor() {
        super("meesign.TaskDecision", [
            { no: 1, name: "task", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "accept", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TaskDecision>): TaskDecision {
        const message = { task: new Uint8Array(0), accept: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TaskDecision>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskDecision): TaskDecision {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes task */ 1:
                    message.task = reader.bytes();
                    break;
                case /* bool accept */ 2:
                    message.accept = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskDecision, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes task = 1; */
        if (message.task.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.task);
        /* bool accept = 2; */
        if (message.accept !== false)
            writer.tag(2, WireType.Varint).bool(message.accept);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.TaskDecision
 */
export const TaskDecision = new TaskDecision$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskAcknowledgement$Type extends MessageType<TaskAcknowledgement> {
    constructor() {
        super("meesign.TaskAcknowledgement", [
            { no: 1, name: "task_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TaskAcknowledgement>): TaskAcknowledgement {
        const message = { taskId: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TaskAcknowledgement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskAcknowledgement): TaskAcknowledgement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes task_id */ 1:
                    message.taskId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskAcknowledgement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes task_id = 1; */
        if (message.taskId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.taskId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.TaskAcknowledgement
 */
export const TaskAcknowledgement = new TaskAcknowledgement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogRequest$Type extends MessageType<LogRequest> {
    constructor() {
        super("meesign.LogRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LogRequest>): LogRequest {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogRequest): LogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.LogRequest
 */
export const LogRequest = new LogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequest$Type extends MessageType<SubscribeRequest> {
    constructor() {
        super("meesign.SubscribeRequest", []);
    }
    create(value?: PartialMessage<SubscribeRequest>): SubscribeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRequest): SubscribeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message meesign.SubscribeRequest
 */
export const SubscribeRequest = new SubscribeRequest$Type();
/**
 * @generated ServiceType for protobuf service meesign.MPC
 */
export const MPC = new ServiceType("meesign.MPC", [
    { name: "GetServerInfo", options: {}, I: ServerInfoRequest, O: ServerInfo },
    { name: "Register", options: {}, I: RegistrationRequest, O: RegistrationResponse },
    { name: "Sign", options: {}, I: SignRequest, O: Task },
    { name: "Group", options: {}, I: GroupRequest, O: Task },
    { name: "Decrypt", options: {}, I: DecryptRequest, O: Task },
    { name: "GetTask", options: {}, I: TaskRequest, O: Task },
    { name: "UpdateTask", options: {}, I: TaskUpdate, O: Resp },
    { name: "DecideTask", options: {}, I: TaskDecision, O: Resp },
    { name: "AcknowledgeTask", options: {}, I: TaskAcknowledgement, O: Resp },
    { name: "GetTasks", options: {}, I: TasksRequest, O: Tasks },
    { name: "GetGroups", options: {}, I: GroupsRequest, O: Groups },
    { name: "GetDevices", options: {}, I: DevicesRequest, O: Devices },
    { name: "Log", options: {}, I: LogRequest, O: Resp },
    { name: "SubscribeUpdates", serverStreaming: true, options: {}, I: SubscribeRequest, O: Task }
]);

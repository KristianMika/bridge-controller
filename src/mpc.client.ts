// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "mpc.proto" (package "meesign", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { MPC } from "./mpc";
import type { SubscribeRequest } from "./mpc";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { LogRequest } from "./mpc";
import type { Devices } from "./mpc";
import type { DevicesRequest } from "./mpc";
import type { Groups } from "./mpc";
import type { GroupsRequest } from "./mpc";
import type { Tasks } from "./mpc";
import type { TasksRequest } from "./mpc";
import type { TaskAcknowledgement } from "./mpc";
import type { TaskDecision } from "./mpc";
import type { Resp } from "./mpc";
import type { TaskUpdate } from "./mpc";
import type { TaskRequest } from "./mpc";
import type { DecryptRequest } from "./mpc";
import type { GroupRequest } from "./mpc";
import type { Task } from "./mpc";
import type { SignRequest } from "./mpc";
import type { RegistrationResponse } from "./mpc";
import type { RegistrationRequest } from "./mpc";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ServerInfo } from "./mpc";
import type { ServerInfoRequest } from "./mpc";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service meesign.MPC
 */
export interface IMPCClient {
    /**
     * @generated from protobuf rpc: GetServerInfo(meesign.ServerInfoRequest) returns (meesign.ServerInfo);
     */
    getServerInfo(input: ServerInfoRequest, options?: RpcOptions): UnaryCall<ServerInfoRequest, ServerInfo>;
    /**
     * @generated from protobuf rpc: Register(meesign.RegistrationRequest) returns (meesign.RegistrationResponse);
     */
    register(input: RegistrationRequest, options?: RpcOptions): UnaryCall<RegistrationRequest, RegistrationResponse>;
    /**
     * @generated from protobuf rpc: Sign(meesign.SignRequest) returns (meesign.Task);
     */
    sign(input: SignRequest, options?: RpcOptions): UnaryCall<SignRequest, Task>;
    /**
     * @generated from protobuf rpc: Group(meesign.GroupRequest) returns (meesign.Task);
     */
    group(input: GroupRequest, options?: RpcOptions): UnaryCall<GroupRequest, Task>;
    /**
     * @generated from protobuf rpc: Decrypt(meesign.DecryptRequest) returns (meesign.Task);
     */
    decrypt(input: DecryptRequest, options?: RpcOptions): UnaryCall<DecryptRequest, Task>;
    /**
     * @generated from protobuf rpc: GetTask(meesign.TaskRequest) returns (meesign.Task);
     */
    getTask(input: TaskRequest, options?: RpcOptions): UnaryCall<TaskRequest, Task>;
    /**
     * auth required
     *
     * @generated from protobuf rpc: UpdateTask(meesign.TaskUpdate) returns (meesign.Resp);
     */
    updateTask(input: TaskUpdate, options?: RpcOptions): UnaryCall<TaskUpdate, Resp>;
    /**
     * auth required
     *
     * @generated from protobuf rpc: DecideTask(meesign.TaskDecision) returns (meesign.Resp);
     */
    decideTask(input: TaskDecision, options?: RpcOptions): UnaryCall<TaskDecision, Resp>;
    /**
     * auth required
     *
     * @generated from protobuf rpc: AcknowledgeTask(meesign.TaskAcknowledgement) returns (meesign.Resp);
     */
    acknowledgeTask(input: TaskAcknowledgement, options?: RpcOptions): UnaryCall<TaskAcknowledgement, Resp>;
    /**
     * @generated from protobuf rpc: GetTasks(meesign.TasksRequest) returns (meesign.Tasks);
     */
    getTasks(input: TasksRequest, options?: RpcOptions): UnaryCall<TasksRequest, Tasks>;
    /**
     * @generated from protobuf rpc: GetGroups(meesign.GroupsRequest) returns (meesign.Groups);
     */
    getGroups(input: GroupsRequest, options?: RpcOptions): UnaryCall<GroupsRequest, Groups>;
    /**
     * @generated from protobuf rpc: GetDevices(meesign.DevicesRequest) returns (meesign.Devices);
     */
    getDevices(input: DevicesRequest, options?: RpcOptions): UnaryCall<DevicesRequest, Devices>;
    /**
     * auth optional
     *
     * @generated from protobuf rpc: Log(meesign.LogRequest) returns (meesign.Resp);
     */
    log(input: LogRequest, options?: RpcOptions): UnaryCall<LogRequest, Resp>;
    /**
     * auth required
     *
     * @generated from protobuf rpc: SubscribeUpdates(meesign.SubscribeRequest) returns (stream meesign.Task);
     */
    subscribeUpdates(input: SubscribeRequest, options?: RpcOptions): ServerStreamingCall<SubscribeRequest, Task>;
}
/**
 * @generated from protobuf service meesign.MPC
 */
export class MPCClient implements IMPCClient, ServiceInfo {
    typeName = MPC.typeName;
    methods = MPC.methods;
    options = MPC.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * @generated from protobuf rpc: GetServerInfo(meesign.ServerInfoRequest) returns (meesign.ServerInfo);
     */
    getServerInfo(input: ServerInfoRequest, options?: RpcOptions): UnaryCall<ServerInfoRequest, ServerInfo> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<ServerInfoRequest, ServerInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: Register(meesign.RegistrationRequest) returns (meesign.RegistrationResponse);
     */
    register(input: RegistrationRequest, options?: RpcOptions): UnaryCall<RegistrationRequest, RegistrationResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<RegistrationRequest, RegistrationResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: Sign(meesign.SignRequest) returns (meesign.Task);
     */
    sign(input: SignRequest, options?: RpcOptions): UnaryCall<SignRequest, Task> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<SignRequest, Task>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: Group(meesign.GroupRequest) returns (meesign.Task);
     */
    group(input: GroupRequest, options?: RpcOptions): UnaryCall<GroupRequest, Task> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<GroupRequest, Task>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: Decrypt(meesign.DecryptRequest) returns (meesign.Task);
     */
    decrypt(input: DecryptRequest, options?: RpcOptions): UnaryCall<DecryptRequest, Task> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<DecryptRequest, Task>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: GetTask(meesign.TaskRequest) returns (meesign.Task);
     */
    getTask(input: TaskRequest, options?: RpcOptions): UnaryCall<TaskRequest, Task> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<TaskRequest, Task>("unary", this._transport, method, opt, input);
    }
    /**
     * auth required
     *
     * @generated from protobuf rpc: UpdateTask(meesign.TaskUpdate) returns (meesign.Resp);
     */
    updateTask(input: TaskUpdate, options?: RpcOptions): UnaryCall<TaskUpdate, Resp> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<TaskUpdate, Resp>("unary", this._transport, method, opt, input);
    }
    /**
     * auth required
     *
     * @generated from protobuf rpc: DecideTask(meesign.TaskDecision) returns (meesign.Resp);
     */
    decideTask(input: TaskDecision, options?: RpcOptions): UnaryCall<TaskDecision, Resp> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<TaskDecision, Resp>("unary", this._transport, method, opt, input);
    }
    /**
     * auth required
     *
     * @generated from protobuf rpc: AcknowledgeTask(meesign.TaskAcknowledgement) returns (meesign.Resp);
     */
    acknowledgeTask(input: TaskAcknowledgement, options?: RpcOptions): UnaryCall<TaskAcknowledgement, Resp> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<TaskAcknowledgement, Resp>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: GetTasks(meesign.TasksRequest) returns (meesign.Tasks);
     */
    getTasks(input: TasksRequest, options?: RpcOptions): UnaryCall<TasksRequest, Tasks> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<TasksRequest, Tasks>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: GetGroups(meesign.GroupsRequest) returns (meesign.Groups);
     */
    getGroups(input: GroupsRequest, options?: RpcOptions): UnaryCall<GroupsRequest, Groups> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<GroupsRequest, Groups>("unary", this._transport, method, opt, input);
    }
    /**
     * @generated from protobuf rpc: GetDevices(meesign.DevicesRequest) returns (meesign.Devices);
     */
    getDevices(input: DevicesRequest, options?: RpcOptions): UnaryCall<DevicesRequest, Devices> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<DevicesRequest, Devices>("unary", this._transport, method, opt, input);
    }
    /**
     * auth optional
     *
     * @generated from protobuf rpc: Log(meesign.LogRequest) returns (meesign.Resp);
     */
    log(input: LogRequest, options?: RpcOptions): UnaryCall<LogRequest, Resp> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<LogRequest, Resp>("unary", this._transport, method, opt, input);
    }
    /**
     * auth required
     *
     * @generated from protobuf rpc: SubscribeUpdates(meesign.SubscribeRequest) returns (stream meesign.Task);
     */
    subscribeUpdates(input: SubscribeRequest, options?: RpcOptions): ServerStreamingCall<SubscribeRequest, Task> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<SubscribeRequest, Task>("serverStreaming", this._transport, method, opt, input);
    }
}
